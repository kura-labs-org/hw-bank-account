# -*- coding: utf-8 -*-
"""class BankAccount

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1coF0alVVgAyyePIYNw3Juz0s14h_mo7c

# Bank Account v 1.10
## Patch Notes
### *New Features*
**Transfer**: We've added the transfer function! You can now transfer funds between accounts with ease!

**Floats**: More comprehensive monetary information. You can now deposit/withdraw/see how much change is in your bank account.

###*Updates*
**Withdraw**: You can no longer withdraw more money than is in your bank account. Unforunately this is a necessary change so that we can continue to serve you.

**Slimmer Design** We combined functionality of separate processes on our backend to deliver a more seamless user experience. (***Specifically I combined transactionTracker and performMoreTransactions into one function because I realized both were executing at the end of each transaction. Fewer and smaller blocks of code providing the same service will increase performance)***

###*Bug Fixes*
**Smoother Driving** Less crashes since we've squashed some bugs.

---
(See old version of the class for comparison at the bottom)
"""

#from main import routing_number            # fake import statement to emulate importing routing number from some main bank library
routing_number = 120000120                  # with the above import the routing number declaration would be unnecessary, but it is needed here since there is no main bank library.
import random                               # for locking PIN
import datetime                             # for logging transactions

class Bank:                                 # Bank class will hold the database of accounts. When each BankAccount is initilialized, account # and name will be stored (line 23) 

  def __init__(self):
    self.all_account_numbers = {}
    self.all_account_balances = {}


class BankAccount():
  nums = 1000

  def __init__(self, name, pin):
    self.name = name
    self.pin = pin
    try:
      self.balance = float(bank.all_account_balances[self.name.lower()])
    except:
      self.balance = 0
    self.routing_number = routing_number
    self.account_number = BankAccount.nums
    self.transactions = []
    self.text_user_interface_dictionary = {1: self.checkBalance, 2 : self.deposit, 3 : self.withdraw, 4: self.sendTransfer, 5 : self.printStatement, 6 : self.printStatement}
    bank.all_account_numbers[self.account_number] = self.name.lower()
    bank.all_account_balances[self.name.lower()] = self.balance
    BankAccount.nums += 1



  def accessAccount(self):                                                      # access the bank account through pin checking. lock the account if the user fails the pin check 3x
    locked = False

    for i in range(3):
      pin_attempt = int(input("Please enter your PIN. "))

      if pin_attempt == self.pin:
        print(f"Welcome, {self.name}")
        self.text_user_interface()
        break
      else: 
        print("Please try again!")
      locked = True

    if locked:
      self.pin = int(format(random.randint(0000 , 9999), '04d'))
      print("Your account has been locked, please see a representative.")
 
  
  def text_user_interface(self):                                                # text user interface. display options for bank account
  
    while True:
      try:                                                                 # originally had the key's as "check balance", "deposit", etc., but numbers are easier to input
        user_input = int(input(f"Please select an option: \n 1 = Check Balance \n 2 = Despoit \n 3 = Withdraw \n 4 = Transfer Funds \n 5 = Print Statement\n 6 = End Session \n"))
      
        try:
          self.text_user_interface_dictionary[user_input]()
          break
        except:
          print("Invalid response. Please enter a valid number.")

      except ValueError:
        print("Invalid response. Please enter a valid number.")


  def checkBalance(self):                                                       # ":.2f" notation forces the float to two decimal places. This specific format is for f strings.
    print(f" Your current balance: ${self.balance:.2f}")                        
    self.performMoreTransactions(f"Checked Balance: ${self.balance:.2f} @ {datetime.datetime.now()}")


  def deposit(self):
    deposit = float(input("How much would you like to deposit? "))
    self.balance += deposit
    print("Please enter cash. \n Please wait... Please wait... \n Deposit successful!")
    self.performMoreTransactions(f"Deposit : ${deposit:.2f} @ {datetime.datetime.now()}")


  def withdraw(self):
   
    while True:
      withdraw = float(input("How much would you like to withdraw? "))
  
      if (self.balance < withdraw):
        print("Insufficient Funds. Please enter a value equal to or less than your total balance.")
      else:
        self.balance -= withdraw
        break

    print("Please wait for cash. \n Please wait... Please wait... \n Funds dispensed!")
    self.performMoreTransactions(f"Withdraw : ${withdraw:.2f} @ {datetime.datetime.now()}")


  def sendTransfer(self):
    transfer_account_number = int(input("Please enter the account # you'd like to transfer funds to: "))
    transfer_amount = int(input("Please enter the amount you'd like to transfer: "))
    self.balance -= transfer_amount


    bank.all_account_balances[bank.all_account_numbers[transfer_account_number]] += transfer_amount
    print(f"Transfer to {transfer_account_number} in the amount of : ${transfer_amount:.2f} was successful!")

    self.performMoreTransactions(f"Transfer to {transfer_account_number} in the amount of : ${transfer_amount:.2f} @ {datetime.datetime.now()}")
    

  def printStatement(self):                                                     # gives detailed information about the account and the current session. also ends the session
    print(f"Thank you for visiting us, today! We hope to see you soon, {self.name}. \n Routing Number: {self.routing_number} \n Account Number: {self.account_number} \n Current Balance: ${self.balance:.2f} \n Transactions Today: {self.transactions} \n Have a nice day!")
    bank.all_account_balances[self.name.lower()] = self.balance


  def performMoreTransactions(self, transaction_type):                     
    
    self.transactions.append(transaction_type)                                  # logs to the transactions list                                                      
                                                                            
    while True:                                                                 #  for switching services / ending the session. redirects to printStatement to end.
      back_to_text_user_interface = input("Would you like to perform more transactions? Y or N? ").lower()

      if back_to_text_user_interface == "y":
        self.text_user_interface()
        break
      elif back_to_text_user_interface == 'n':
        self.printStatement()
        break
      else:
        print("Invalid response.")
        
bank = Bank()

fronchi_bank_account = BankAccount("Fronchi", 7892)
francisco_bank_account = BankAccount("Francisco", 1010)

print(bank.all_account_numbers)
print(bank.all_account_balances)

fronchi_bank_account.accessAccount()
print(bank.all_account_balances)

francisco_bank_account.accessAccount()
print(bank.all_account_balances)
fronchi_bank_account.accessAccount()
print(bank.all_account_balances)

"""### Bank Account v1.00"""

#from main import routing_number            # fake import statement to emulate importing routing number from some main bank library
routing_number = 120000120                  # with the above import the routing number declaration would be unnecessary, but it is needed here since there is no main bank library.
import random                               # for locking PIN
import datetime                             # for logging transactions

class BankAccount:

  def __init__(self, name, pin, balance):
    self.balance = balance
    self.name = name
    self.transactions = []
    self.pin = pin
    self.routing_number = routing_number
    self.account_number = int(format(random.randint(000000000 , 999999999), '09d'))    # look into id function
    self.text_user_interface_dictionary = {1: self.checkBalance, 2 : self.deposit, 3 : self.withdraw, 4 : self.printStatement, 5 : self.performMoreTransactions} 
  

  def accessAccount(self):                                                      # access the bank account through pin checking. lock the account if the user fails the pin check 3x
    locked = False

    for i in range(3):
      pin_attempt = int(input("Please enter your PIN. "))

      if pin_attempt == self.pin:
        print(f"Welcome, {self.name}")
        self.text_user_interface()
        break
      else: 
        print("Please try again!")
      locked = True

    if locked:
      self.pin = int(format(random.randint(0000 , 9999), '04d'))
      print("Your account has been locked, please see a representative.")
 
  
  def text_user_interface(self):                                                                # text user interface. display options for bank account
  
    while True:                                                                 # originally had the key's as "check balance", "deposit", etc., but numbers are easier to input
      user_input = int(input(f"Please select an option: \n 1 = Check Balance \n 2 = Despoit \n 3 = Withdraw \n 4 = Print Statement\n 5 = End Session \n"))
     
      try:
        return self.text_user_interface_dictionary[user_input]()
      except:
        print("Invalid response. Please enter a number.")
    

  def checkBalance(self):
    print(f" Your current balance: ${self.balance}")
    self.transactionTracker(f"Checked Balance: ${self.balance} @ {datetime.datetime.now()}")
    self.performMoreTransactions()


  def deposit(self):
    deposit = int(input("How much would you like to deposit? "))
    self.balance += deposit
    print("Please enter cash. \n Please wait... Please wait... \n Deposit successful!")
    self.transactionTracker(f"Deposit : ${deposit} @ {datetime.datetime.now()}")
    self.performMoreTransactions()


  def withdraw(self):
    withdraw = int(input("How much would you like to withdraw? "))
    self.balance -= withdraw
    print("Please wait for cash. \n Please wait... Please wait... \n Funds dispensed!")
    self.transactionTracker(f"Withdraw : ${withdraw} @ {datetime.datetime.now()}")
    self.performMoreTransactions()


  def printStatement(self):                                                     # gives detailed information about the account and the current session. also ends the session
    print(f"Thank you for visiting us, today! We hope to see you soon, {self.name}. \n Routing Number: {self.routing_number} \n Account Number: {self.account_number} \n Current Balance: ${self.balance} \n Transactions Today: {self.transactions} \n Have a nice day!")
    

  def transactionTracker(self, transaction_type):                               # logs to the transactions list
    self.transactions.append(transaction_type)


  def performMoreTransactions(self):                                                      # for switching services / ending the session. redirects to printStatement to end.
    checker = True
    
    while checker:
      back_to_text_user_interface = input("Would you like to perform more transactions? Y or N? ").lower()

      if back_to_text_user_interface == "y":
        checker = False
        self.text_user_interface()
      elif back_to_text_user_interface == 'n':
        self.printStatement()
        break
      else:
        print("Invalid response.")
        

fronchi_bank_account = BankAccount("Francisco", 7892, 1414)
fronchi_bank_account.accessAccount()

"""### ISAAC'S CLASSES"""

from random import randint

class Bank:
  """ Bank's job is to keep a record of all accounts and users
      A bank can also create a user or an account or both """
  def __init__(self):
    self.users = [] # list of Users
    self.accounts = [] # list Accounts
  
  def create_user_and_account(self, first_name, last_name, password, bal = 0):
    """ Uses firstname, lastname, and password to create user.. Can pass a balance (int)
        returns tuple of user and account that was created """
    new_user = self.create_user(first_name, last_name)
    new_account = self.create_account(new_user, password, bal)
    return (new_user, new_account)

  def create_account(self, user, password, bal):
    """ Uses user/password bal to make an account
        returns the account that was created """
    new_account = Account(user, bal)
    new_account.set_password(password)
    new_account.bank = self
    self.accounts.append(new_account)
    return new_account
  
  def create_user(self, first_name, last_name):
    """ Uses firstname, lastname to make user
        returns the user that was created """
    new_user = User(first_name, last_name)
    self.users.append(new_user)
    return new_user
  
  def find_account_by_id(self, id):
    for account in self.accounts:
      if account.account_id == id:
        return account
    return None
  
  def get_all_account_info(self):
    """ Returns a string of account info determined by Account.get_account_info() """
    return [acct.get_account_info() for acct in self.accounts]

class Account:
  """ Account represents an individual account. An account holds all of the
      information and behaviors needed for working with an account.
      password for Authenticating user, transaction capabilities like depositing,
      viewing balance and seeing all account info """

  subtract_types = ["Withdrawal", "Transfer"] # Used to determin how to handle transaction
  account_number_counter = 189866

  def __init__(self, user, bal = 0):
    Account.account_number_counter += 1
    self.account_id = str(Account.account_number_counter)
    self.balance = bal                    # total balance
    self.user = user                      # User object associated with this account
    self.transactions = []                # will hold all transactions
    self.password = None
    self.bank = None

  def validate_transaction(self, transaction):
    """ Given a transaction, we check it's type and check the balance supports
        the transaction.
        returns an object with transaction status and message """
    if transaction.trans_type in self.subtract_types:
      if transaction.amount > self.balance:
        return {"status": "failed", "message": "Insufficient Funds"}
    if transaction.trans_type == "Transfer":
      self.alert_bank_of_transfer(transaction)
    self.update_balance(transaction)
    self.transactions.append(transaction)
    return {"status": "passed", "message": f'Your {transaction.trans_type} was successful'}

  def set_password(self, password):
    self.password = password

  def update_balance(self, transaction):
    """ Given a transaction, adds or subtracts to balance """
    if transaction.trans_type in self.subtract_types and transaction.recipient != self.account_id:
      self.balance -= transaction.amount
    else:
      self.balance += transaction.amount

  def withdraw(self, amount):
    """ Create a transaction of withdrawal type and validates """
    withdrawal = Transaction("Withdrawal", amount)
    return self.validate_transaction(withdrawal)
  
  def deposit(self, amount):
    """ Create a transaction of deposit type and validates """
    deposit = Transaction("Deposit", amount)
    return self.validate_transaction(deposit)

  def transfer(self, amount, account):
    """ Create a transaction of transfer type and validates """
    transfer = Transaction("Transfer", amount, account, self.account_id)
    return self.validate_transaction(transfer)
  
  def recieve_transfer(self, transfer):
    self.update_balance(transfer)
  
  def authenticate(self, password):
    """ returns whether password given matches password on record """
    return password == self.password
  
  def get_transactions(self):
    """ returns transaction history """
    return self.transactions
    
  def get_account_info(self):
    """ returns string of account info """
    return f'|({self.user.first_name} {self.user.last_name}) {self.account_id} : ${self.balance} {self.password} |'

  def alert_bank_of_transfer(self, transfer):
    account = self.bank.find_account_by_id(transfer.recipient)
    if account is not None:
      account.recieve_transfer(transfer)
      return {"status": "passed", "message": f"recipient recieved transfer of {transfer.amount}"}
    else:
      return {"status": "failed", "message": f"Transfer failed"}

class User:
  """ Represents the a user
      currently only has first and last name. Can add methods to update other info"""
  def __init__(self, first_name, last_name):
    self.user_id = self.accountId = randint(10000,100000)
    self.first_name = first_name
    self.last_name = last_name
    self.salary = None
    self.address = None
    self.dob = None

class Transaction:
  """ Represents a transaction. Made it like this so bank can support all types
  of transactions in the future """
  def __init__(self, trans_type, amount, recipient = None, sender = None):
    self.trans_type = trans_type
    self.amount = amount
    self.recipient = recipient
    self.sender = sender

  def __str__(self):
    """ ALL object have an __str__ method that you can overwrite
    you just have to return a string and when you print this object, this
    is the string that will return """
    return f'type: {self.trans_type}, amount: {self.amount}, recipient: {self.recipient}'

class BankSession:
  """ Represents the interface that one would interact with. This holds all of the
      prompts and interacts with the user and controls the flow of the bank session """
  def __init__(self, bank):
    self.bank = bank           # Needs a bank to start
    self.current_account = None # This is the account that's currently logged in

  def action(self, user_action):
    """ Contains all of the actions that a user can do """
    actions = {
        "balance": self.get_balance,
        "withdraw": self.withdraw,
        "transfer": self.transfer,
        "deposit": self.deposit,
        "history": self.get_history
    }
    return actions.get(user_action, self.wrong_input)() # use get to enable default action when mistype

  def load_user(self):
    """ Asks user if has account. If yes, asks for id and password, if not, creates on and logs in """
    result = input("Do you have an account? (yes/no) ")
    accepted_response = ["yes", "no"]
    while result not in accepted_response:
      result = input("Please enter a correct response. Do you have an account? (yes/no) ")
    if result == "yes":
      accountId = input("Enter your account id: ")
      password = input("Enter your password: ")

      found_account = self.find_account_by_id(accountId)
      if found_account and found_account.authenticate(password):
        self.current_account = found_account
        print("You are logged in")
      elif found_account and not found_account.authenticate(password):
        print("Incorrect password")
      else:
        print("Could not find an account with that id")
    else:
      first_name = input("What is your first name?: ")
      last_name = input("What is your last name?: ")
      password = input("create a password: ")
      self.current_account = self.bank.create_user_and_account(first_name, last_name, password)
    
  def display_prompts(self):
    prompt = ("\n\nWhat would you like to do next?\n"+
                "Check your balance? (balance)\n"+
                "Deposit money? (deposit)\n" +
                "Withdraw money? (withdraw)\n"+
                "Transfer funds? (transfer)\n"+
                "Get transaction history? (history)"+
                "exit (exit)")
    return input(prompt)

  def session_loop(self):
    """ This is where the user is asked the prompt. Will continuously be asked
        until the user types in exit """
    if self.current_account:
      user_response = self.display_prompts()
      while user_response != "exit":
        self.action(user_response)
        user_response = self.display_prompts()

  def get_balance(self):
    """ Get's balance of the currently logged in account """
    print(f"Your current balance is ${self.current_account.balance}")
  
  def withdraw(self):
    """ Takes an integer as an input and subtracts from balance """
    amount = int(input("How much would you like to withdraw?: "))
    response = self.current_account.withdraw(amount)
    print(response["message"])
    self.get_balance()

  def transfer(self):
    """ HAS NOT BEEN IMPLEMENTED YET """
    account = input("Please enter the account you would like to transfer to: ")
    amount = int(input("How much would you like to transfer?: "))

    found_account = self.bank.find_account_by_id(account)
    if found_account:
      response = self.current_account.transfer(amount, account)
      print(response["message"])
    else:
      print("Not a valid account")

  def get_history(self):
    """ Returns the transactions of the currently logged in account """
    print("This is your transaction history", *self.current_account.get_transactions())

  def deposit(self):
    """ Takes an integer as an input and adds that to balance """
    amount = int(input("How much would you like to deposit?: "))
    response = self.current_account.deposit(amount)
    print(response["message"])
    self.get_balance()
  
  def find_account_by_id(self, id):
    """ Given an id, searches for the account in the bank accounts list"""
    for account in self.bank.accounts:
      if account.account_id == id:
        return account
    return None

  def wrong_input(self):
    """ Default response when user puts a wrong input in the session loop"""
    print("You didn't enter a correct option.. Please try again")

def run():  
  # initializing bank
  bank = Bank()

  # adding users to banks records, some with balances others with no balances
  print("You can log into any of these users")
  _, account1 = bank.create_user_and_account("Isaac", "Barrezueta", "password1", 1000)
  _, account2 = bank.create_user_and_account("Dan", "C", "password2")
  _, account3 = bank.create_user_and_account("Mo", "D", "password3")

  # printing information for all accounts
  print(*bank.get_all_account_info())

  # initializing a bank session with the bank we made
  bankSession = BankSession(bank)

  # loading user and starting prompt
  bankSession.load_user()
  bankSession.session_loop()

  # Bank session closed and showing all accounts' info again
  print(*bank.get_all_account_info())


if __name__ == '__main__':
  run()